################################################################
## SPECIFIC TO SANGER, BUT COULD BE USED ON ANY LSF SYSTEM    ##
## BY DAMON-LEE B POINTON (DLBPointon)                        ##
## WRITTEN: 07/2025                                           ##
################################################################

# Time converter so we can get days running
convert_time() {
    local output=$1
    local time=$2

    # Extract header line to find RUN_TIME column index
    local header
    header=$(printf '%s\n' "$output" | head -n1)

    # Find the column index of RUN_TIME
    local col_index
    col_index=$(awk -v FS="\t" '
        NR==1 {
            for (i=1; i<=NF; i++)
                if ($i=="RUN_TIME") { print i; exit }
        }' <<< "$header")

    # 86400 seconds in a day
    # days = total seconds / secs in a day
    # hurs = (remainder of days) / 60
    # mins = (remainder of hours) / 60
    # secs = (remainder of total / 60)
    awk -v col="$col_index" -v mode="$time" '
        BEGIN {
            FS = "\t";
            OFS = "\t";
        }
        NR==1 {
            print; next;
        }
        {
            col_data = $col
            if (match(col_data, /^[0-9]+:[0-5][0-9]:[0-5][0-9]$/)) {
                split(col_data, t, ":");
                total = t[1]*3600 + t[2]*60 + t[3];
                if (mode=="secs") {
                    $col = total;
                } else if (mode=="days") {
                    days = int(total / 86400);
                    hrs  = int((total % 86400) / 3600);
                    mins = int((total % 3600) / 60);
                    secs = total % 60;
                    $col = sprintf("%02dd %02d:%02d:%02d", days, hrs, mins, secs);
                }
            }
            print;
        }' <<< "$output"
}

# Central function to the whole thing
betterbj () {
	local name_max="${1:-40}"
	local user_name="${2:-${USER}}"
	local time="${3:-"days"}"
	local queue="${4:-}"

   	local output
    output=$(bjobs -o "ID STAT QUEUE NAME:-${name_max} MAX_REQ_PROC:7 cpu_peak:7 memlimit:8 MEM:8 MAX_MEM:8 FIRST_HOST:-12 START_TIME RUN_TIME delimiter='\\'" \
       	-hms -u "${user_name}" ${queue} \
	| sed 's/\\/\t|\t/g' \
	| sed 's/MAX_REQ/CPU_REQ/g' \
	| sed 's/CPU_PEA/CPU_USE/g')

    # Functionally a return
    echo "$(convert_time "${output}" "${time}")"
}

# Get betterbj per queue
bjuniq_queues () {
	local name_max="${1:-40}"
        local user_name="${2:-${USER}}"
	betterbj ${name_max} ${user_name} | sed 1d | cut -f 5 | sort | uniq
}

# Customise the betterbj data for colours and columns
bjdata () {
     local name_len="${1:-40}"
     local user_name="${2:-${USER}}"
     local time="${3:-"days"}"
     local bjuniq=$(bjuniq_queues ${name_len} ${user_name})
     # Shared awk script for coloring + sorting
     local colorize_and_sort='
     BEGIN {
	     FS="\t"
	     OFS="\t"
	     reset = "\033[0m"
	     green_underline = "\033[32;4m"
	     red = "\033[31m"
	     green = "\033[32m"
	     yellow = "\033[33m"
	     blue = "\033[34m"
	     cyan = "\033[36m"
	   }
	   NR==1 { print green_underline $0 reset; next }  # header
	   {
		# Status coloring
		if ($3 == "RUN")        $3 = green $3 reset
		else if ($3 == "PEND")  $3 = yellow $3 reset
		else                    $3 = red $3 reset

		# Queue coloring
		if ($5 == "normal")              $5 = green $5 reset
		else if ($5 == "hugemem")        $5 = yellow $5 reset
		else if ($5 == "terramem")       $5 = red $5 reset
		else if ($5 == "oversubscribed") $5 = blue $5 reset
		else if ($5 == "week")           $5 = blue $5 reset
		else if ($5 == "long")           $5 = cyan $5 reset

		print | "sort -k1"
	}'

	# Loop through queues
	for i in $bjuniq; do
		if [ "$i" != "oversubscribed" ]; then
			lines=$(betterbj "$name_len" "$user_name" "$time" "-q ${i}")
			if [ "$( echo "$lines" | wc -l)" -gt 1 ] ; then
				echo -e "\033[33m>-- Group for: \x1b[4m${i^^}\033[0m\033[33m | User ${user_name}\033[0m"
				echo "$lines" \
				  | awk "$colorize_and_sort" \
				  | column -t -s $'\t'

               	# Make gap between tables
               	echo -e "\n"
			fi
		fi
	done

	# Handle oversubscribed specially
	lines=$(betterbj 52 "$user_name" "$time" "-q oversubscribed")
	if [ "$( echo "$lines" | wc -l)" -gt 1 ] ; then
		echo -e "\033[33m>-- Group for: \x1b[4mOVERSUBSCRIBED\x1b[0m\033[33m | User: ${user_name} | uses alt function calls\033[0m"
		echo "$lines" \
		  | sed 's/sanger/S1/g' \
		  | sed 's/singularity/S2/g' \
		  | sed 's/production/P1/g' \
		  | sed 's/ASCC_ASCC/ASCC/g' \
		  | sed 's/SANGER_TOL/S-TOL/g' \
		  | awk "$colorize_and_sort" \
		  | column -t -s $'\t'
	fi
}

# Main cli function
bjobber () {
	local width=40
	local time="days"
	local user_name="$USER"

	while [[ $# -gt 0 ]]; do
		case "$1" in
			-u|--user)
				user_name=$2
			    	shift 2;;
			-w|--width)
				width="$2"
				shift 2;;
			-t|--time)
				time=$2
				shift 2;;
			-c|--c_column)
			    c_column=$2
				shift 2;;
			-h|--help)
				echo "Usage: bjobber [-u USER] [-w WIDTH]"
				echo " --user       | USERNAME to report on | default is \$USER"
				echo " --width      | WIDTH of bjob name as output | default is 40"
				echo " --time       | RUN TIME in H:M:S (no), D:H:M:S (days), S (secs)"
				echo " --c_custom   | custom columns for BJOB output (not yet supported)"
				return 0
				;;
			*)
				echo "UNKOWN ARG: $i"
				return 1
				;;
		esac
	done

	bjdata "$width" "$user_name" "$time"

	# Get count of jobs in queue AND status
	echo -e "\nJob Queue Counter"
	bjobs -o "queue stat" -u "$user_name" | awk '{ if ($1 != "QUEUE") print $2 "\t" $1}' | sort | uniq -c

	# Get raw count of jobs per status
	echo -e "\nStatus Counter"
	bjobs -o "stat" -u "$user_name" | awk '{ if ($1 != "STAT") print $1}' | sort | uniq -c
}
